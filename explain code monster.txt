using UnityEngine;

public class MonsterMovement : MonoBehaviour
{
    public float speed = 1f; // T·ªëc ƒë·ªô di chuy·ªÉn
    public float leftLimit = 2.21f; // Gi·ªõi h·∫°n b√™n tr√°i
    public float rightLimit = 6.04f; // Gi·ªõi h·∫°n b√™n ph·∫£i
    private bool movingRight = true; // H∆∞·ªõng di chuy·ªÉn
    /*movingRight: M·ªôt bi·∫øn Boolean ƒë·ªÉ ki·ªÉm so√°t h∆∞·ªõng di chuy·ªÉn c·ªßa qu√°i.

    true: Qu√°i ƒëang di chuy·ªÉn sang ph·∫£i.

    false: Qu√°i ƒëang di chuy·ªÉn sang tr√°i. */

    public float PhamViPhatHienNhanVat = 3f; //Ph·∫°m vi m√† qu√°i b·∫Øt ƒë·∫ßu r∆∞·ª£t theo nh√¢n v·∫≠t


    private SpriteRenderer spriteRenderer; // ƒê·ªÉ l·∫≠t h√¨nh qu√°i
    private Transform player; // L∆∞u v·ªã tr√≠ nh√¢n v·∫≠t

    void Start()
    {
        spriteRenderer = GetComponent<SpriteRenderer>(); // L·∫•y SpriteRenderer t·ª´ qu√°i
        player = GameObject.FindGameObjectWithTag("Player").transform; // t√¨m nh√¢n v·∫≠t c√≥ tag player
    }

    void Update()
    {
       float KhoangCachToiNhanVat = Vector2.Distance(transform.position, player.position);
        // T√≠nh kho·∫£ng c√°ch gi·ªØa qu√°i v√† nh√¢n v·∫≠t

        if(KhoangCachToiNhanVat < PhamViPhatHienNhanVat)
        {
            DuoiTheoNhanVat();
        }
        else
        {
            TuanTra();
        }

        void TuanTra()
        {
            // Di chuy·ªÉn qu√°i
            if (movingRight)
            {
                transform.Translate(Vector2.right * speed * Time.deltaTime);
                // transform.Translate(): ƒê√¢y l√† h√†m c·ªßa Unity ƒë∆∞·ª£c s·ª≠ d·ª•ng ƒë·ªÉ di chuy·ªÉn ƒë·ªëi t∆∞·ª£ng. 
                // Vector2.right ƒë·∫°i di·ªán cho h∆∞·ªõng sang ph·∫£i tr√™n tr·ª•c X (t·ªça ƒë·ªô: (1, 0)).
                // Time.deltaTime: th·ªùi gian th·ª±c gi·ªØa hai khung h√¨nh (frame). ƒêi·ªÅu n√†y gi√∫p di chuy·ªÉn m∆∞·ª£t m√† v√† kh√¥ng ph·ª• thu·ªôc v√†o t·ªëc ƒë·ªô x·ª≠ l√Ω c·ªßa m√°y t√≠nh. N·∫øu FPS th·∫•p, qu√°i v·∫´n di chuy·ªÉn ch√≠nh x√°c.
                if (transform.position.x >= rightLimit)
                // transform.position.x: L·∫•y v·ªã tr√≠ hi·ªán t·∫°i c·ªßa qu√°i tr√™n tr·ª•c X.
                {
                    movingRight = false; // ƒê·ªïi h∆∞·ªõng sang tr√°i
                    FlipSprite(); // L·∫≠t h√¨nh
                }
            }
            else
            {
                transform.Translate(Vector2.left * speed * Time.deltaTime);
                if (transform.position.x <= leftLimit)
                {
                    movingRight = true; // ƒê·ªïi h∆∞·ªõng sang ph·∫£i
                    FlipSprite(); // L·∫≠t h√¨nh
                }
            }
        }

        void DuoiTheoNhanVat()
        {
            Vector2 PhuongHuong;
            if(player.position.x > transform.position.x)
            // N·∫øu player.x l·ªõn h∆°n qu√°i.x ‚Üí t·ª©c l√† nh√¢n v·∫≠t ƒëang ·ªü b√™n ph·∫£i qu√°i.
            {
                PhuongHuong = Vector2.right; // V·∫≠y h∆∞·ªõng r∆∞·ª£t s·∫Ω l√†: Vector2.right ‚Üí ƒëi sang ph·∫£i.

                if (!movingRight) // N·∫øu qu√°i ƒëang kh√¥ng nh√¨n sang ph·∫£i (ƒëang nh√¨n tr√°i)
                {
                    movingRight = true; // Quay l·∫°i h∆∞·ªõng ph·∫£i
                    FlipSprite(); // L·∫≠t sprite ƒë·ªÉ quay m·∫∑t qua ph·∫£i
                }
            }
            else //N·∫øu player.x < qu√°i.x ‚Üí qu√°i ph·∫£i r∆∞·ª£t sang tr√°i.
            {
                PhuongHuong = Vector2.left;
                // V√¨ nh√¢n v·∫≠t ƒëang ·ªü b√™n tr√°i (x nh·ªè h∆°n), n√™n qu√°i ph·∫£i ƒëi sang tr√°i
                if (movingRight)  // N·∫øu qu√°i ƒëang nh√¨n ph·∫£i, m√† gi·ªù ph·∫£i quay tr√°i
                {
                    movingRight = false;
                    FlipSprite();
                }
            }
            transform.Translate(PhuongHuong * speed * Time.deltaTime);
        }
       
    }

    // H√†m l·∫≠t h√¨nh qu√°i
    void FlipSprite()
    {
        spriteRenderer.flipX = !spriteRenderer.flipX;
    }

    void OnDrawGizmosSelected()
    /*void OnDrawGizmosSelected()
    ƒê√¢y l√† h√†m c·ªßa Unity, s·∫Ω ƒë∆∞·ª£c t·ª± ƒë·ªông g·ªçi m·ªói khi b·∫°n ch·ªçn GameObject (v√≠ d·ª• con qu√°i) trong c·ª≠a s·ªï Scene.

    N√≥ KH√îNG ch·∫°y trong Game, ch·ªâ ƒë·ªÉ b·∫°n d·ªÖ h√¨nh dung khi ch·ªânh scene. */
    {
        Gizmos.color = Color.red;
        /*Gizmos.color = Color.red;
        D√≤ng n√†y ƒë·∫∑t m√†u c·ªßa gizmo s·∫Øp ƒë∆∞·ª£c v·∫Ω ‚Äî ·ªü ƒë√¢y l√† m√†u ƒë·ªè.

        Gizmos.color l√† thu·ªôc t√≠nh m√†u cho c√°c h√¨nh d·∫°ng s·∫Ω ƒë∆∞·ª£c v·∫Ω sau ƒë√≥ */
        Gizmos.DrawWireSphere(transform.position, PhamViPhatHienNhanVat);
        /*Gizmos.DrawWireSphere(transform.position, PhamViPhatHienNhanVat);
        V·∫Ω m·ªôt v√≤ng tr√≤n r·ªóng (wireframe) ‚Äì gi·ªëng nh∆∞ m·ªôt c√°i "v√≤ng radar".

        transform.position l√† v·ªã tr√≠ hi·ªán t·∫°i c·ªßa qu√°i.

        PhamViPhatHienNhanVat l√† b√°n k√≠nh c·ªßa v√≤ng tr√≤n ‚Üí t·ª©c l√† qu√°i c√≥ th·ªÉ ph√°t hi·ªán nh√¢n v·∫≠t trong b√°n k√≠nh ƒë√≥. */
    }

}
/* public float PhamViPhatHienNhanVat = 3f;

 * Nghƒ©a l√†: qu√°i s·∫Ω r∆∞·ª£t theo nh√¢n v·∫≠t n·∫øu nh√¢n v·∫≠t c√°ch qu√°i nh·ªè h∆°n 3 ƒë∆°n v·ªã.
Trong Unity, kho·∫£ng c√°ch ƒë∆∞·ª£c t√≠nh theo Vector2 (t·ªça ƒë·ªô X, Y), v√† ƒë∆°n v·ªã n√†y l√† "world units" ‚Äì hay c√≥ th·ªÉ hi·ªÉu ƒë∆°n gi·∫£n nh∆∞:

1f ‚âà 1 √¥ tile / 1 ƒë∆°n v·ªã kh√¥ng gian.

N·∫øu b·∫°n d√πng Tilemap, m·ªói tile l√† 1 ƒë∆°n v·ªã.

N·∫øu Player c√°ch qu√°i kho·∫£ng 3 √¥ tr·ªü xu·ªëng ‚Üí b·ªã ph√°t hi·ªán. */

/*1. float KhoangCachToiNhanVat = Vector2.Distance(transform.position, player.position);
üëâ M·ª•c ƒë√≠ch:
T√≠nh kho·∫£ng c√°ch gi·ªØa qu√°i v√† nh√¢n v·∫≠t ƒë·ªÉ bi·∫øt:

Nh√¢n v·∫≠t c√≥ ƒëang ·ªü g·∫ßn qu√°i kh√¥ng?

C√≥ c·∫ßn r∆∞·ª£t theo kh√¥ng?

üí¨ Ph√¢n t√≠ch t·ª´ng ph·∫ßn:
üîπ transform.position
ƒê√¢y l√† v·ªã tr√≠ c·ªßa qu√°i v·∫≠t trong th·∫ø gi·ªõi game (t·ªça ƒë·ªô X, Y).

V√≠ d·ª•: qu√°i ƒëang ·ªü (2, 0).

üîπ player.position
ƒê√¢y l√† v·ªã tr√≠ c·ªßa nh√¢n v·∫≠t.

V√≠ d·ª•: nh√¢n v·∫≠t ƒëang ·ªü (5, 0).

üîπ Vector2.Distance(a, b)
H√†m c√≥ s·∫µn trong Unity ƒë·ªÉ t√≠nh kho·∫£ng c√°ch gi·ªØa hai ƒëi·ªÉm a v√† b.

Trong to√°n h·ªçc, n√≥ gi·ªëng nh∆∞ c√¥ng th·ª©c:
distance = cƒÉn (x2 - x1) b√¨nh ph∆∞∆°ng + (y2 - y1) b√¨nh ph∆∞∆°ng
‚û°Ô∏è Trong v√≠ d·ª• tr√™n:
Vector2.Distance((2,0), (5,0)) = 3f ‚Üí t·ª©c l√† nh√¢n v·∫≠t c√°ch qu√°i 3 ƒë∆°n v·ªã.

üí° K·∫øt lu·∫≠n:
N·∫øu KhoangCachToiNhanVat < PhamViPhatHienNhanVat
‚Üí Qu√°i th·∫•y nh√¢n v·∫≠t v√† b·∫Øt ƒë·∫ßu ƒëu·ªïi theo!
  */

/*transform.Translate(...) l√† g√¨?
csharp
Copy
Edit
transform.Translate(PhuongHuong * speed * Time.deltaTime);
‚úÖ ƒê√¢y l√† h√†m d√πng ƒë·ªÉ di chuy·ªÉn ƒë·ªëi t∆∞·ª£ng.
üìñ C·∫•u tr√∫c:
transform: l√† c√°i "v·ªè" ch·ª©a v·ªã tr√≠, xoay, scale c·ªßa ƒë·ªëi t∆∞·ª£ng trong Unity.

.Translate(...): l√† d·ªãch chuy·ªÉn ƒë·ªëi t∆∞·ª£ng t·ª´ v·ªã tr√≠ hi·ªán t·∫°i.

PhuongHuong: l√† h∆∞·ªõng di chuy·ªÉn (tr√°i ho·∫∑c ph·∫£i).

speed: t·ªëc ƒë·ªô.

Time.deltaTime: ƒë·ªÉ ƒë·∫£m b·∫£o chuy·ªÉn ƒë·ªông m∆∞·ª£t v√† ƒë√∫ng th·ªùi gian (FPS cao hay th·∫•p ƒë·ªÅu kh√¥ng ·∫£nh h∆∞·ªüng). */